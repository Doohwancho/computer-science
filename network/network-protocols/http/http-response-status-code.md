---\
Index


A. Informational responses (100 – 199)\
B. Successful responses (200 – 299)\
C. Redirection messages (300 – 399)\
D. Client error responses (400 – 499)\
E. Server error responses (500 – 599)


latest update: RFC-9110\
ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status


---
# A. 100번대 - 정보
-   요청이 수신되어 처리중이며, 계속해서 프로세스를 진행한다.
-   **최근에는 1xx 상태코드를 거의 사용하지 않는다.**

## A.1. 100 Continue

진행 중임을 의미하는 응답코드입니다. 현재까지의 진행상태에 문제가 없으며, 클라이언트가 계속해서 요청을 하거나 이미 요청을 완료한 경우에는 무시해도 되는 것을 알려줍니다.

## A.2. 101 Switching Protocol

101은 클라이언트에 의해 보낸 업그레이드 요청 헤더에 대한 응답으로 보내집니다.

이 응답 코드는 클라이언트가 보낸 Upgrade 요청 헤더에 대한 응답에 들어가며, 서버에서 프로토콜을 변경할 것임을 알려줍니다. 해당 코드는 Websocket 프로토콜 전환 시에 사용됩니다.

## A.3. 102 Processing(WebDAV)

이 응답 코드는 서버가 요청을 수신하였으며 이를 처리하고 있지만, 아직 제대로 된 응답을 알려줄 수 없음을 알려줍니다.




# B. 200번대 - 성공
## B.1. 200 OK

요청이 성공적으로 완료되었으며, 정보를 함께 반환할 수 있다.

## B.2. 201 Created

요청에 성공해서 그 결과로 새로운 리소스가 생성되었다. (주로 회원가입과 같은 새로운 리소스 생성에 많이 사용한다. with POST, PUT)

## B.3. 202 Accepted

요청이 접수 되었으나 아직 처리가 완료되지 않았다.

ex. 요청 접수 1시간 후 배치 프로세스가 요청을 처리하는 배치 처리에 주로 사용된다.
ex. 1시간 후 게시글 삭제 예약


## B.4. 204 No Content

요청을 성공적으로 수행했지만 응답 페이로드 본문에 보낼 데이터가 없음.
단, 리소스가 캐시된 헤더를 새로운 것으로 업데이트 할 수 있음.


ex) 웹 문서 편집기의 save 버튼 : sava버튼을 눌러도 화면상 아무런 변화는 없다. 결과 내용은 없지만 204 상태코드로 해당 작업의 성공을 인식시켜 줄 수 있다.

ex) 리소스의 삭제가 정상적으로 처리되었을 때 사용할 수 있다.

## B.5. Reset Content

이 응답 코드는 요청을 완수한 이후에 사용자 에이전트에게 이 요청을 보낸 문서 뷰를 리셋하라고 알려줍니다.


## B.6. Partial Content

이 응답 코드는 클라이언트에서 복수의 스트림을 분할 다운로드를 하고자 범위 헤더를 전송했기 때문에 사용됩니다. 클라이언트가 이어받기를 시도하면 웹서버가 이에 대한 응답코드로 '206 Partial Content'와 함께 Range 헤더에 명시된 데이터의 부분(byte)부터 전송을 시작합니다.


# C. 300번대 - redirect
기본적으로 웹 브라우저는 3xx 응답 결과에 Location 헤더가 있으면 해당 Location 위치로 자동 이동한다.
```
HTTP/1.1 301 Moved permanently
Location: /new-event
```
자동으로 /new-event 페이지로 이동한다.

## C.1. 영구 리다이렉션 - 특정 리소스의 URL이 영구적으로 이동한다. (301, 308)

### C.1.1. 301 Moved Permanetly

요청한 리소스의 URI가 변경되었음을 의미한다.
URI의 요청 방식이 GET으로 변할 수 있고, 본문이 제거될 수 있다.


ex.
예를들어 주소창에 `http://naver.com/`을 입력하면, `301`을 리턴하는데,

응답 헤더의 Location을 확인해보면 `http://www.naver.com/`으로 리다이렉션 된다.

웹브라우저는 이 코드를 받고, 해당하는 URL로 리다이렉트한다.


### C.1.2. Permanent Redirect

`301`과 비슷하게 사용된다. 차이가 있다면 `301`의 경우는 영구적으로 이동하는 것이고, `302`의 경우, 일시적으로 이동한다는 것이다.

예를들어, `kart.nexon.com` 같은 게임페이지에 접속할 때, 메인 홈페이지가 아닌 현재 진행중인 이벤트를 보여주는 홈페이지로 일시적으로 이동시킨다.

위 예시의 경우 `kart.nexon.com` > `kart.nexon.com/redirector.aspx` > `kart.nexon.com/events/~` 의 절차를 통해 이벤트 페이지로 이동하게 된다.




## C.2.  일시 리다이렉션 - 일시적인 변경으로, 실무에서 많이 사용한다.

예를들어, 쇼핑몰에서 주문을 완료하면 주문 내역 화면으로 이동되는 경우가 있다.

만약 리다이렉션을 하지 않고 주문 완료 페이지에 머무르다가 사용자가 새로고침을 하게된다면 ?

최악의 경우 중복 결제가 일어날 수 있다. PRG(post-redirect-get) 순으로 진행되어 GET 요청 결과 하면을 리턴, 중복 주문을 방지할 수 있다.


### C.2.1. 302 Found

이 응답 코드는 요청한 리소스의 URI가 일시적으로 변경되었음을 의미합니다. 새롭게 변경된 URI는 나중에 만들어질 수 있습니다. 그러므로, 클라이언트는 향후의 요청도 반드시 동일한 URI로 해야합니다.


리다이렉트 요청 메소드가 GET 으로 변하고 본문이 제거될 수 있음


### C.2.2. 303 See other

302와 동일한 기능이지만, 명확하게 GET으로 변경해서 리다이렉션 해준다.

(302의 대용으로 등장했으나, 이미 수 많은 프로젝트에서 302를 사용하고 있어서 정확히 어떤 상태코드를 사용해야 한다 라는 정의는 없다.)


### C.2.3. 307 Temporary Redirect

클라이언트가 요청한 리소스가 다른 URI에 있으며 이전 요청과 동일한 메소드를 사용해서 요청해야 할 때 서버가 클라이언트에 요청을 직접 보낸다. 기존의 요청 메소드(GET/POST 등)는 변경되면 안되며(만약 첫 요청에 POST가 사용되었다면, 두번째 요청도 반드시 POST를 사용해야 함), 본문 또한 유지되어야 함



## C.3. 특수 리다이렉션 - 결과 대신 캐시를 사용

### C.3.1. 304 Not Modified

캐시를 목적으로 사용한다.

클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬PC에 저장된 캐시를 재사용 한다. 또한 304 응답은 바디에 메시지를 포함하면 안된다. (로컬 캐시를 그대로 사용해야 하기 때문에)



# D. 400번대 - client쪽 실패

## D.1. 400 Bad Request

가장 많이 사용되는 4xx 에러로 요청 구문 또는 메시지 등의 오류가 있을 때 사용한다. 클라이언트는 요청 내용을 다시 검토후 보내야 한다.

## D.2. 401 Unauthorized

클라이언트가 해당 리소스에 대한 인증이 필요하다. 예를들어 로그인이 필요한 환경에 비로그인으로 접근했을 경우 발생시킬 수 있다.

응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명해서 보낼 수 있다.

## D.3. 402 Payment Required
이 응답 코드는 나중에 사용될 것을 대비해 예약되었습니다. 첫 목표로는 디지털 결제 시스템에 사용하기 위하여 만들어졌지만 지금 사용되고 있지는 않습니다.


## D.4. 403 Forbidden

서버가 요청을 이해 했지만 승인을 거부하는 경우 발생시킬 수 있다. 주로 인증은 완료되었지만, 접근 권한이 불충분한 경우로 예를들어 Admin등급이 아닌 사용자가 로그인(인증)은 완료했지만, Admin 등급 이상 접근 가능한 리소스에 접근했을 경우 발생한다.

### D.4.1. status code 401 vs 403

두 코드의 차이점은

-   `401`의 경우는 인증이 되지 않은 경우이다. 예를 들어 로그인이 필요한 기능을 로그인 하지 않은 상태로 요청하면 `401`이 적절하다.
-   `403`의 경우는 권한이 없는 경우이다. 예를 들어 어떤 카페에서 로그인은 되어있는 상태이지만 등급이 낮아 접속 권한이 없을 때는 `403`이 적절하다.
	- 403은 서버가 클라이언트가 누구인지 알고 있습니다.



## D.5. 404 Not Found

비 개발자도 알고있는 404 Error. 대부분 요청 리소스가 없을때 발생한다.

추가적으로 403과 같이 클라이언트가 권한이 부족한 리소스에 접근했을 경우 페이지를 숨기는 용도로도 가끔씩 사용한다.
(해커한테 권한에 대한 정보 숨기기 위해서 fake로 사용)

## D.6. 406 Not Acceptable

이 응답은 서버가 '서버 주도 콘텐츠 협상'을 수행한 후, 사용자 에이전트에서 정해준 규격에 따른 어떠한 콘텐츠도 찾지 않았을 때, 웹서버가 보냅니다.


## D.7. 408 Request Timeout

이 응답은 요청을 한 지 시간이 오래된 연결에 일부 서버가 전송하며, 어떤 때에는 이전에 클라이언트로부터 어떠한 요청이 없었다고 하더라도 보내지기도 합니다. 이것은 서버가 사용되지 않는 연결을 끊고 싶어하는 것을 의미합니다. 이 응답은 특정 몇몇 브라우저에서 빈번하게 보이는데 Chrome, Firefox 27+, 또는 IE 9와 같은 웹서핑 속도를 올리기 위해 HTTP 사전 연결 메카니즘을 사용하는 브라우저들이 해당됩니다. 또한 일부 서버는 이 메시지를 보내지 않고 연결을 끊어버리기도 합니다.

## D.8. 409 Conflict

현재 서버의 상태와 충돌했을 때 사용한다. 정확한 정의는 존재하지 않지만, 닉네임이나 아이디 중복의 경우 이미 서버에 존재하는 리소스(닉네임/아이디)와 충돌해서 발생하는 중복 에러를 다루기도 한다.

## D.9. 410 Gone

일시적으로 사용하던 이벤트 페이지(지금은 종료된 이벤트)에 접근했을 때 해당 페이지는 영구적으로 삭제되었다고 알리는 역할을 할 수 있다. 404로 대체 가능해서 잘 사용하지 않는다.

이 응답은 요청한 콘텐츠가 서버에서 영구적으로 삭제되었으며, 전달해 줄 수 있는 주소 역시 존재하지 않을 때 보냅니다. 클라이언트가 그들의 캐시와 리소스에 대한 링크를 지우기를 기대합니다. HTTP 기술 사양은 이 상태 코드가 '일시적인, 홍보용 서비스'에 사용되기를 기대합니다. API는 알려진 리소스가 이 상태 코드와 함께 삭제되었다고 강요해서는 안된다.

## D.10. 412 Precondition Failed

클라이언트의 헤더에 있는 전제조건은 서버의 전제조건에 적절하지 않습니다.

## D.11. 413 Payload Too Large

요청 엔티티는 서버에서 정의한 한계보다 큽니다. 서버는 연결을 끊거나 혹은 Retry-After 헤더 필드로 돌려보낼 것이다.

## D.12. 415 Unsupported Media Type

요청한 미디어 포맷은 서버에서 지원하지 않습니다. 서버는 해당 요청을 거절할 것입니다.


## D.13. 429 Too Many Requests

사용자가 지정된 시간에 너무 많은 요청을 보냈습니다("rate limiting").



# E. 500번대 - server쪽 실패

## E.1. 500 Internal Server Error

웹 서버에 문제가 있을 때 발생하는 에러로, 서버에 발생하는 에러의 원인을 정확히 파악하지 못한 경우(애매할 경우) 500으로 처리한다.

## E.2. 501 Not Implemented

서버가 요청을 이행하는 데 필요한 기능을 지원하지 않음을 나타냅니다.

## E.3. 502 Bad Gateway

서버가 게이트웨이로부터 잘못된 응답을 수신했음을 의미합니다. 인터넷상의 서버가 다른 서버로부터 유효하지 않은 응답을 받은 경우 발생합니다.

## E.4. 503 Service Unavailable

서버가 요청을 처리할 준비가 되지 않았을때 사용한다. 서비스 점검(유지/보수)시 일시적으로 서버의 작동을 중단시킬 때 사용하며 Retry-After : 503(Server Unavailable) 과 함께 사용할 수 있다.

그러나 서버 오류는 대부분 예측이 불가능할 때 나타나기 때문에 503을 볼 일은 거의 없다.

Retry-After : 날짜 표기로, 언제부터 ~ 언제까지 서비스 이용이 불가능한지 표현 가능


