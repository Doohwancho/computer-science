#include <stdio.h>
#include <math.h>

void print_binary(unsigned int value) {
    for (int i = sizeof(unsigned int) * 8 - 1; i >= 0; i--) {
        printf("%d", (value >> i) & 1);
        if (i % 8 == 0 && i != 0) {
            printf(" ");
        }
    }
    printf("\n");
}

//16진수를 bit로 표현
// 0: 0000
// 1: 0001
// 2: 0010
// 3: 0011
// 4: 0100
// 5: 0101
// 6: 0110
// 7: 0111
// 8: 1000
// 9: 1001
// A: 1010
// B: 1011
// C: 1100
// D: 1101
// E: 1110
// F: 1111

int main() {
    //case1) 음수 
    unsigned int a = 0b11111111; //2진수(binary) -> 0000 0000 0000 0000 0000 0000 1111 1111
    unsigned int b = 0b11111110; //2진수(binary) -> 0000 0000 0000 0000 0000 0000 1111 1110
    int c = 0x7FFFFFFF; //16진수 -> 0111 1111 1111 1111 1111 1111 1111 1111
    //Q. 0b와 0x의 차이?
    //A. 0b는 2진수, 0x는 16진수인데,
    //   0b는 전체 비트를 표현하고(ex. 0b00001111000011110000111100001111), 이런식으로 전체 bit를 써야 함. 안그러면 맨 오른쪽부터 처리됨
    //   0x는 4bit 단위로 표현함. (F-> 1111, 7 -> 0111) 
    //   ex. 0x7FFFFFFF -> 0111 1111 / 1111 1111 / 1111 1111 / 1111 1111
    int d = pow(2,31)-1; //16진수 -> 0111 1111 1111 1111 1111 1111 1111 1111 (c와 같음)
    unsigned int e = 0xFFFFFFFF; //16진수 -> 1111 1111 1111 1111 1111 1111 1111 1111 (양수, b/c unsigned)
    int f = 0xFFFFFFFF; //16진수 -> 1111 1111 1111 1111 1111 1111 1111 1111 (음수)

    printf("a: %d, b: %d, c: %d, d: %d\n", a, b, c, d); //255, 254, 2147483647, 2147483647
    // print_binary(c); 
    // print_binary(d); 
    printf("e: %u, f: %d\n", e, f); //4294967295, -1  <--- 맨 앞에 1을 unsigned는 양수 취급, signed는 음수 취급해서 생기는 일 

    return 0;
}